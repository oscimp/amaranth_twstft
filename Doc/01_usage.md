# Cmod A7 integration
Back to the [README](../README.md)
Previous step : [Installation of Amaranth and cie](00_Installation.md)

This section details how to flash the gateware and how to configure the FPGA via UART serial.

## bitstream generation

```
usage: flashZedBoard.py [-h] [--platform PLATFORM] [--bitlen BITLEN] [--noiselen NOISELEN] [-m MODFREQ] [-p] [-v]
                        [--no-build] [--no-load] [--flash] [--build-dir BUILD_DIR] [--conv-to-bin]
                        [--toolchain TOOLCHAIN]

options:
  -h, --help            show this help message and exit
  --platform PLATFORM   Target Platform (cmoda7 only for now)
  --bitlen BITLEN       number of bits of the LFSR
  --noiselen NOISELEN   length of the PRN sequence
  -m MODFREQ, --modfreq MODFREQ
                        frequency of the PSK modulation (Herz) (default :2.5e6)
  -v, --verbose         prints all the parameters used for this instance of the program
  --no-build            sources generate only
  --no-load             don't load bitstream
  --flash               write bitstream into SPI flash (cmoda7 only)
  --build-dir BUILD_DIR
                        build directory
  --conv-to-bin         convert .bit file to .bit.bin
  --toolchain TOOLCHAIN
                        toolchain to use (Vivado or Symbiflow) (cmoda7 only) (default: Vivado)
```


Requiered options:
- `BITLEN` is the *PRN* shift register size ([Pseudo-Random Noise generation](02_PRN.md)) (default: 17)
- `NOISELEN` is the number of bits produces before reseting the *PRN* shift register (default: 100000)

Optional options:
- `--no-build` limit to amaranth -> *verilog* convert
- `--no-load` bypass load step after bitstream
- `--flash` write the bitstream in non-volatile memory, by default, the bitstream is writen to volatile memory.

for example:
```
./amaranth_twstft/flashZedBoard.py --bitlen 17 --noiselen 100000
```

**cmoda7 only**: by default *Vivado* is used to produces the bitstream, but it's
also possible to use the *f4pga* Open-Source toolchain.

## Configuration

At runtime, the fpga can be configured with the `twstft_config.py` script.

```
usage: twstft_config.py [-h] [-d DEVICE] [-b BAUDRATE] [-l BITLEN] [-m] [--list] [-p] [-ta TAPS_A] [-tb TAPS_B]
                        [--prn N] [-t] [-M {OFF,CARRIER,BPSK,QPSK}] [-T {OFF,INVERT_FIRST_CODE,TIMECODE}]
                        [-C {OFF,CLK,PPS}]

options:
  -h, --help            show this help message and exit
  -d DEVICE, --device DEVICE
  -b BAUDRATE, --baudrate BAUDRATE
                        serial baudrate
  -l BITLEN, --bitlen BITLEN
                        the bitlen of the fpga's LFSR. Hardwired in FPGA's gateware, this option doesn't modify it's
                        config but is requiered to communicate properly the taps settings
  -m, --monitor         keep listning and print debug signals to stdout
  --list                list available devices
  -p, --pps             when monitoring, also print debug signal for valid and expected PPS
  -ta TAPS_A, --taps-a TAPS_A
                        set taps for LFSR A (BPSK & QPSK)
  -tb TAPS_B, --taps-b TAPS_B
                        set taps for LFSR B (QPSK only)
  --prn NOISELEN        save a PRN of N bits generated by given taps
  -t, --set-time        set FPGA's time to computer's time
  -M {OFF,CARRIER,BPSK,QPSK}, --mode {OFF,CARRIER,BPSK,QPSK}
                        turn OFF / set modulation mode
  -T {OFF,INVERT_FIRST_CODE,TIMECODE}, --time-mode {OFF,INVERT_FIRST_CODE,TIMECODE}
                        set timecode mode
  -C {OFF,CLK,PPS}, --calib-mode {OFF,CLK,PPS}
                        set calibration mode
```

### Conecting to the device

`./twstft_config.py --list` will list available serial ports.
`DEVICE` must be set to the one connected to the FPGA.

### Setting taps and generating PRN

The taps of both LFSR can be set independetly with:
```
./twstft_config.py -d DEVICE -l BITLEN -t{a|b} TAPS
```
Where `BITLEN` is the size of the LFSR, and the same as the `BITLEN` specified at bitstream generation.

To save the generated PRN to disk:
```
./twstft_config --prn NOISELEN -l BITLEN -ta TAPS_A [-tb TAPS_B]
```
If both taps are specified, the two prn are interlaced bit by bit.

Options are fully compatible, and can be passed in one command :
```
./twstft_config.py -d /dev/ttyUSB1 -l 17 -ta 9 -tb 15 --prn 100000
```
Will set the LFSR taps on the FPGA to 9 and 15, and save both 100000 bits PRN interlaced in a 200K file (1 bit per byte).

**Note:** setting LFSR's taps to zero disable it. At reset, both taps are set to zero.

### Enable and configure antena output

The modulation scheme can be set with:
```
./twstft_config.py -d DEVICE -M MODE
```

Where `MODE` can be:
 - `OFF` disable antena output and output a constant low signal.
 - `CARRIER` output clean 70MHz carrier.
 - `BPSK` output BPSK modulated by LFSR A
 - `QPSK` output QPSK modulated orthogonaly by LFSRs A and B

**Note**: At reset, mode is set to `OFF`.

### Enable timecode

This option allows to encode the second start or even the seconds of the minute in the phases of PRNs.
It is set with:
```
./twstft_config.py -d DEVICE -T MODE
```

Where `MODE` can be:
 - `OFF` disable time encoding
 - `INVERT_FIRST_CODE` at each PPS, the phase of the first PRN is flipped, allowing time comparison between clocks with more than a PRN's length in offset, as long as the offset is less than half a second.
 - `TIMECODE` at each PPS, the phase of the first PRN is flipped, and the phases of the 6 following PRNs encode the seconds of the minute from 0 to 59. Allowing time comparison between clocks with as much as 30 seconds offset.

 **Note**: At reset, timecode is disabled.

When using `TIMECODE`, to set the fpga's seconds counter, use `--set-time` to set the fpga's time to computer's time.

### Calibration output

Option `-C` sets the output off the calibration pin. It's usage is described in the next section. During normal use, this setting should be set to `OFF`.

**Note**: At reset, this is set to `OFF`.

### Monitoring

When recieving a PPS, the FPGA starts a timer that takes one second to finish. When an unexpected PPS is recieved, a warning is send via UART to the computer.
To monitor these warnings, use option `-m`. To also get messages when the PPS arrives at the right time, add `--pps`.

All option, are compatibles, when using `-m`, all config modifications are performed before the monitoring begins.
It is also possible to modify config while another instance of the script is monitoring, but beware that the monitoring will crash if another instance tries to read from the serial port.


## Pin functions


| function              | dir | <a href="https://digilent.com/reference/programmable-logic/cmod-a7/reference-manual">cmoda7</a> |
|-----------------------|-----|--------|
| 10MHz in              | in  | GPIO46 |
| PPS in                | in  | GPIO42 |
| calibration           | out | GPIO36 |
| output                | out | GPIO31 |
| UART-i                | in  | micro-USB |
| UART-o                | out | micro-USB |

Next step : [Pseudo-Random Noise generation](02_PRN.md)
